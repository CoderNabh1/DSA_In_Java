Max size of Array is 10^7.

It has Contiguous Memory Locations.

You can'nt use For-Each loop in java for insertion of elements.

.toArray() in ArrayList, HashSet

To remove duplicates add the last element by your own.

For second Largest element in the array find the largest and then compare it with other other with a not equal to case.

To left rotate a array K times you should first do K = K%Size of Array as it decreases the no. of array rotations.

For right rotation do k = n-k for right rotation.

Optimised solution of left rotating array is to first rotate the two sub arrays and then the full --> Total no. of rotations = 3.
Explanaton of this Algo. --> 
1. Reverse the subarray to 0 to k
2. Reverse the another subarray to k to arr.length
3. Reverse the Whole subarrray

To reverse a element we use two pointer approach
While(start < end)
{
    int temp = arr[start];
    arr[start] = arr[end];
    arr[end] = temp;
    start++;
    end--;
}

int maximum limit (2,147,483,647).

to implement Binary Search --> It should be a sorted Array.
1. First claculate mid = start+(end-start)/2 --> To cancel out int OverFlow Error
2. if (mid<k) start = mid + 1;
3. if(mid>k) end = mid - 1;

When you don't know the size of the array before hand use ArrayList.

Sum of Number from 1 to n = (n*n+1)/2

if you XOR same Numbers the XOR of that is 0.
0^1 = 0 and you have to add the last element by your own which will be +1 of the arr.length.

When you have Pair and you want to find Unnique element XOR can be a good idea.

Longest subarray Sum:--
    Brute
        1. maxL = 0, not equal to Integer.MIN_VALUE
        2. We do 3 Loop for it.
        3. length = j-i+1
        4. to insert choosen subarray
            arr[index++] = arr[i]
    
    Better
        1. maxL = 0, not equal to Integer.MIN_VALUE
        2. We do 2 Loop for it.
        3. is that now we are not repeating the sum it's like first it will do for 1 to n then 2 to n then then 3 to n and in this way it 's n*n
        4. length = j-i+1
        5. to insert choosen subarray
            arr[index++] = arr[i]

    Solution
        1. Sliding Window
        2. When the next element you find is greater than the sum remove the first element og the window till summ is less than or equal to k.
        3. When the sum is equal to k note the position.
        4. Repeat Step--> 2 
        The time complexity of it on looking may look like O(n^2) but as the both pointers inside it is moving in single direcition n times so it is (O(n+n)) --> O(n)


Minimize Maximum Pair Sun in an Array
    Intution --> Basically you have to think what should i do to balance out the addition.
    1. You can Sort the Array or simply just select the current max and current min of the array.
    2. Save their sum and remove them if you are not sorting it.
    3. Repeat the process.

Two Sum
    1. Store the elements in HashSet
    2. do the arr[i]-k
    3. search it in set
    4. if not found add it to the set.

To rotate the Array by left
    1. Make a ArrayList
    2. Remove the first element
    3. use.add() so that it automatically adds up in the last of the array.

Sliding window
    1. initalize start.
    2. initalize end = start+range-1;
    3. while(start<end) or while(end<arr.length)

National Dutch Flag Algo.
    1. to sort an array containing three distinct values (usually 0, 1, and 2) in linear time $O(N)$ and constant space $O(1)$.
    2. maintain 3 pointers to divide the array into 4 conceptual regions:
        1. low: The boundary for 0s.
        2. mid: The current element being considered.
        3. high: The boundary for 2s.

    3. the array is divided into 4 regions at any point during execution:-
        1. 0 to low - Contains all 0s (Extreme Left).
        2. low to mid - Contains all 1s.
        3. mid to high - Contains Unsorted elements (This is the range we are currently processing).
        4. high + 1 to n - Contains all 2s (Extreme Right).
    
    4. The Algorithm Logic we iterate while mid <= high. 
    5. For every element at arr[mid], there are three possibilities:
        1. If arr[mid] == 0 This element belongs in the "0" region (left).
            1. Action: Swap arr[low] with arr[mid].
            2. Move Pointers: Increment low and increment mid.

        2. If arr[mid] == 1 This element is in the correct position relative to the 0s (middle).
            1. Action: Do nothing to the array.
            2. Move Pointers: Just increment mid.

        3. If arr[mid] == 2 This element belongs in the "2" region (right).
            1. Action: Swap arr[mid] with arr[high].
            2. Move Pointers: Decrement high.

    Note: We do not increment mid here because the element swapped from high has not been checked yet.
    Note: If you mid passes high that means you array is sorted now.

    Use cases include:
        1. Sorting an array of 0s, 1s, and 2s (your code example).
        2. Partitioning elements into three groups (e.g., "Less than X", "Equal to X", "Greater than X").
        3. Separating balls of three different colors.


Majority Element
    Better Approach --:
    1. We Sort The Array.
    2. We look for i and i+1 to be equal and increase the count
    3. else count = 1

    Booyer Moore Voting Algorithm:--
        Logic--> It says that if a element is greater than n/2 times so it will appear atleast 1 time more than the other elements.
        Approach:-
        1. if(count = 0) se the count to 1 and assign the element
        2. if(arr[i] == element) count++;
        3. else count --

        in last you will have a element now check that the element you recieved is really a major element or not.


