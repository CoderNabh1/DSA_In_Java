Max size of Array is 10^7.

It has Contiguous Memory Locations.

You can'nt use For-Each loop in java for insertion of elements.

.toArray() in ArrayList, HashSet

To remove duplicates add the last element by your own.

For second Largest element in the array find the largest and then compare it with other other with a not equal to case.

To left rotate a array K times you should first do K = K%Size of Array as it decreases the no. of array rotations.

For right rotation do k = n-k for right rotation.

Optimised solution of left rotating array is to first rotate the two sub arrays and then the full --> Total no. of rotations = 3.
Explanaton of this Algo. --> 
1. Reverse the subarray to 0 to k
2. Reverse the another subarray to k to arr.length
3. Reverse the Whole subarrray

To reverse a element we use two pointer approach
While(start < end)
{
    int temp = arr[start];
    arr[start] = arr[end];
    arr[end] = temp;
    start++;
    end--;
}

int maximum limit (2,147,483,647).

to implement Binary Search --> It should be a sorted Array.
1. First claculate mid = start+(end-start)/2 --> To cancel out int OverFlow Error
2. if (mid<k) start = mid + 1;
3. if(mid>k) end = mid - 1;

When you don't know the size of the array before hand use ArrayList.

Sum of Number from 1 to n = (n*n+1)/2

if you XOR same Numbers the XOR of that is 0.
0^1 = 0 and you have to add the last element by your own which will be +1 of the arr.length.

When you have Pair and you want to find Unnique element XOR can be a good idea.

Longest subarray Sum:--
    Brute
        1. maxL = 0, not equal to Integer.MIN_VALUE
        2. We do 3 Loop for it.
        3. length = j-i+1
        4. to insert choosen subarray
            arr[index++] = arr[i]
    
    Better
        1. maxL = 0, not equal to Integer.MIN_VALUE
        2. We do 2 Loop for it.
        3. is that now we are not repeating the sum it's like first it will do for 1 to n then 2 to n then then 3 to n and in this way it 's n*n
        4. length = j-i+1
        5. to insert choosen subarray
            arr[index++] = arr[i]

    Solution
        1. Sliding Window
        2. When the next element you find is greater than the sum remove the first element og the window till summ is less than or equal to k.
        3. When the sum is equal to k note the position.
        4. Repeat Step--> 2 
        The time complexity of it on looking may look like O(n^2) but as the both pointers inside it is moving in single direcition n times so it is (O(n+n)) --> O(n)


Minimize Maximum Pair Sun in an Array
    Intution --> Basically you have to think what should i do to balance out the addition.
    1. You can Sort the Array or simply just select the current max and current min of the array.
    2. Save their sum and remove them if you are not sorting it.
    3. Repeat the process.

Two Sum
    1. Store the elements in HashSet
    2. do the arr[i]-k
    3. search it in set
    4. if not found add it to the set.

To rotate the Array by left
    1. Make a ArrayList
    2. Remove the first element
    3. use.add() so that it automatically adds up in the last of the array.

Sliding window
    1. initalize start.
    2. initalize end = start+range-1;
    3. while(start<end) or while(end<arr.length)

National Dutch Flag Algo.
    1. to sort an array containing three distinct values (usually 0, 1, and 2) in linear time $O(N)$ and constant space $O(1)$.
    2. maintain 3 pointers to divide the array into 4 conceptual regions:
        1. low: The boundary for 0s.
        2. mid: The current element being considered.
        3. high: The boundary for 2s.

    3. the array is divided into 4 regions at any point during execution:-
        1. 0 to low - Contains all 0s (Extreme Left).
        2. low to mid - Contains all 1s.
        3. mid to high - Contains Unsorted elements (This is the range we are currently processing).
        4. high + 1 to n - Contains all 2s (Extreme Right).
    
    4. The Algorithm Logic we iterate while mid <= high. 
    5. For every element at arr[mid], there are three possibilities:
        1. If arr[mid] == 0 This element belongs in the "0" region (left).
            1. Action: Swap arr[low] with arr[mid].
            2. Move Pointers: Increment low and increment mid.

        2. If arr[mid] == 1 This element is in the correct position relative to the 0s (middle).
            1. Action: Do nothing to the array.
            2. Move Pointers: Just increment mid.

        3. If arr[mid] == 2 This element belongs in the "2" region (right).
            1. Action: Swap arr[mid] with arr[high].
            2. Move Pointers: Decrement high.

    Note: We do not increment mid here because the element swapped from high has not been checked yet.
    Note: If you mid passes high that means you array is sorted now.

    Use cases include:
        1. Sorting an array of 0s, 1s, and 2s (your code example).
        2. Partitioning elements into three groups (e.g., "Less than X", "Equal to X", "Greater than X").
        3. Separating balls of three different colors.


Majority Element
    Better Approach --:
    1. We Sort The Array.
    2. We look for i and i+1 to be equal and increase the count
    3. else count = 1

    Booyer Moore Voting Algorithm:--
        Logic--> It says that if a element is greater than n/2 times so it will appear atleast 1 time more than the other elements.
        Approach:-
        1. if(count = 0) se the count to 1 and assign the element
        2. if(arr[i] == element) count++;
        3. else count --

        in last you will have a element now check that the element you recieved is really a major element or not.


Maximum SubArray Sum
    Better Approach --:
    1. We will add the next element directly in the second loop.
    2. check for maxElement

    Kadan's Algorithm:--
    1. calculate sum
    2. update maxSum accordingly
        1. also update start
        2. end of array
    3. whenver sum reaches less than 0
        1. reset sum = 0
        2. The next element is always the candidate so update 
            tempstart = i+1
        

When you want to insert remaining elements in the array 
    1. take a while loop(i<arr.length)
    {
        arr[i++] = anyArray[j++]
    }


Buy Time to Buy Stocks:--
   1. Look for the maximum Profit from starting
   2. don't just take maximum and minimum of array. --> [3,10,1,2]
   3. See for the minimum price in the searching region accordingly.


Permutations
    Approach-1:--
        1. take a data strucute and a freq array and answer list to sotre all the permutations.
        2. Mark the freq array as true with the if condition
        3. In this data strucutre you first input element you choose to start from. 
        4. start recursion
        5. then remove the the last element of the data strucutre
        6. unmark the freq array
        7. Use the base case that if the data structure has all the element then
            1.  add it to the answer.
            2.  return

Next Permutations
    Approach-1:--

    Solution:--    


Leader in Array --> greater than all the elements to its right.
    1. The last element will always be the leader.
    2. Treaverse the array from last.
    3. Look and update the biggest element from last.
    4. Reverse the leader Array after finishing.


Longest Consecutive Sequence:-
    Approach --> 1
    1. Sort The Array.
    2. arr[i] - arr[i - 1] == 1, count it
    3. arr[i] - arr[i - 1] == 0,  //Duplicate: skip it, don't break the sequence
    4. Gap found: check if current sequence was the longest
    // Final check for sequence ending at the very last element.

    Approach --> 2
    1. Only start counting if 'num' is the beginning of a sequence.

Set Matrix Zeroes
    Approach --> 1
    1. Iterate the matrix and and if 0 is found.
    2. move through rows and make 1 --> -1 and leave Zeroes.
    3. move through columns and make 1 --> -1 and leave Zeroes.
    4. Finally run the whole loop and make all -1 --> 0.

    Approach --> 2
    1. Iterate the matrix and and if 0 is found.
        1. Store the it's index in two Arraylist.
    2. After completion of the first loop run a while loop
        1. move through rows and make those elements 0.
        2. move through rows and make those elements 0.

    Approach --> 3


Rotate Matrix By 90
    Approach --> 1
    1. Observer that the result after rotating your matrix
        1. In this start looking the pattern try to find it
        2. Make a forula for it
    2. here afer observing 
        1. the j or original matrix is = i of new matrix.
        2. the i of orginal matrix is = n-i-1; --> I derived this formula.

    Approach --> 2
    1. Transpose of the Matrix
    2. Reverse all the rows using two pointer.


Transpose of a Matrix
    1. It means row becomes column and column becomes row.
    2. arr[i][j] = arr[j][i] basically you have to swap using temp.
    3.  also take care of the inner loop it will run acc. to outer loop.


